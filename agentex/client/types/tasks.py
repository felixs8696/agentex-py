from typing import Optional, List, Literal, Annotated, Union, Dict, Any

from pydantic import Field

from agentex.utils.model_utils import BaseModel


class CreateTaskRequest(BaseModel):
    agent: str = Field(
        ...,
        title="The unique name of the agent to use to run the task",
    )
    prompt: str = Field(
        ...,
        title="The user's text prompt for the task",
    )


class CreateTaskResponse(BaseModel):
    id: str = Field(
        ...,
        title="Unique Task ID",
    )
    agent_id: str = Field(
        ...,
        title="The ID of the agent that is responsible for this task",
    )
    prompt: str = Field(
        ...,
        title="The user's text prompt for the task",
    )


class ContentPartText(BaseModel):
    text: str = Field(
        ...,
        description="The text content."
    )
    type: Literal["text"] = Field(
        ...,
        description="The type of the content part."
    )


class ImageURL(BaseModel):
    url: str = Field(
        ...,
        description="Either a URL of the image or the base64 encoded image data."
    )
    detail: Literal["auto", "low", "high"] = Field(
        ...,
        description="""Specifies the detail level of the image.

Learn more in the
[Vision guide](https://platform.openai.com/docs/guides/vision/low-or-high-fidelity-image-understanding).
"""
    )


class ContentPartImage(BaseModel):
    image_url: ImageURL = Field(
        ...,
        description="The image URL."
    )
    type: Literal["image_url"] = Field(
        ...,
        description="The type of the content part."
    )


ContentPart = Union[ContentPartText, ContentPartImage]


class SystemMessage(BaseModel):
    role: Literal["system"] = Field(
        "system",
        description="The role of the messages author, in this case `system`."
    )
    content: str = Field(
        ...,
        description="The contents of the system message."
    )


class UserMessage(BaseModel):
    role: Literal["user"] = Field(
        "user",
        description="The role of the messages author, in this case `user`."
    )
    content: str = Field(
        ...,
        description="The contents of the user message."
    )


class ToolCall(BaseModel):
    name: str = Field(
        ...,
        description="The name of the function to call."
    )
    arguments: str = Field(
        ...,
        description="""
The arguments to call the function with, as generated by the model in JSON
format. Note that the model does not always generate valid JSON, and may
hallucinate parameters not defined by your function schema. Validate the
arguments in your code before calling your function.
"""
    )


class ToolCallRequest(BaseModel):
    type: Literal["function"] = Field(
        "function",
        description="The type of the tool. Currently, only `function` is supported."
    )
    id: str = Field(
        ...,
        description="The ID of the tool call request."
    )
    function: ToolCall = Field(
        ...,
        description="The function that the model is requesting."
    )


class AssistantMessage(BaseModel):
    role: Literal["assistant"] = Field(
        "assistant",
        description="The role of the messages author, in this case `assistant`."
    )
    content: Optional[str] = Field(
        None,
        description="""The contents of the assistant message.

Required unless `tool_calls` or `function_call` is specified.
"""
    )
    tool_calls: Optional[List[ToolCallRequest]] = Field(
        default_factory=list,
        description="The tool calls generated by the model, such as function calls."
    )


class ToolMessage(BaseModel):
    role: Literal["tool"] = Field(
        "tool",
        description="The role of the messages author, in this case `tool`."
    )
    content: Union[str, List[ContentPart]] = Field(
        ...,
        description="The contents of the tool message."
    )
    tool_call_id: str = Field(
        ...,
        description="Tool call that this message is responding to."
    )
    name: str = Field(
        ...,
        description="The name of the tool called."
    )


Message = Annotated[
    Union[
        SystemMessage,
        UserMessage,
        AssistantMessage,
        ToolMessage
    ],
    Field(
        discriminator="role"
    )
]


class WorkflowState(BaseModel):
    status: str = Field(
        ...,
        title="The status of the task",
    )
    is_terminal: bool = Field(
        ...,
        title="Whether the task is in a terminal state",
    )
    reason: Optional[str] = Field(
        None,
        title="The reason for the terminal state",
    )


class GetTaskResponse(BaseModel):
    id: str = Field(
        ...,
        title="Unique Task ID",
    )
    agent_id: str = Field(
        ...,
        title="The ID of the agent that is responsible for this task",
    )
    prompt: str = Field(
        ...,
        title="The user's text prompt for the task",
    )
    messages: Optional[List[Message]] = Field(
        default_factory=list,
    )
    context: Optional[Dict[str, Any]] = Field(
        default_factory=dict,
    )

    state: WorkflowState = Field(
        ...,
        title="The current state of the task",
    )
